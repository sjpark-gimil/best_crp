/* ==== main.c (no LEDs, no SWV) ==== */
#include "main.h"
#include "gpio.h"
#include "usart.h"
#include <string.h>
#include <stdbool.h>
#include <stdint.h>

/* Prototypes generated by CubeMX (already implemented elsewhere in project) */
void SystemClock_Config(void);
void Error_Handler(void);

/* USART2 from CubeMX */
extern UART_HandleTypeDef huart2;

/* ---------------- Helpers ---------------- */

static void drain_uart(uint32_t ms)
{
  uint8_t d;
  uint32_t t0 = HAL_GetTick();
  for (;;) {
    if (HAL_UART_Receive(&huart2, &d, 1, 5) == HAL_OK) {
      t0 = HAL_GetTick();                 // extend while bytes keep arriving
      continue;
    }
    if ((HAL_GetTick() - t0) >= ms) break;
  }
}

/* Send ASCII command, collect bytes until line is quiet for quiet_ms */
static uint32_t send_and_read(const char *cmd,
                              uint8_t *buf, uint32_t bufsz,
                              uint32_t quiet_ms)
{
  // clear buffer
  for (uint32_t i = 0; i < bufsz; ++i) buf[i] = 0;

  drain_uart(50); // purge old bytes

  // send
  (void)HAL_UART_Transmit(&huart2, (uint8_t*)cmd, (uint16_t)strlen(cmd), 200);

  // collect until quiet
  uint32_t n = 0;
  uint32_t t0 = HAL_GetTick();
  for (;;) {
    uint8_t b;
    if (HAL_UART_Receive(&huart2, &b, 1, 5) == HAL_OK) {
      if (n < bufsz) buf[n++] = b;
      t0 = HAL_GetTick();
      continue;
    }
    if ((HAL_GetTick() - t0) >= quiet_ms) break;
  }
  return n;
}

static void trim_ascii(char *s)
{
  size_t start = 0;
  while (s[start] == '\r' || s[start] == '\n' || s[start] == ' ' || s[start] == '\t')
    start++;
  if (start) memmove(s, s + start, strlen(s + start) + 1);

  size_t len = strlen(s);
  while (len && (s[len-1] == '\r' || s[len-1] == '\n' || s[len-1] == ' ' || s[len-1] == '\t'))
    s[--len] = 0;
}

/* very tolerant parser for a name-like last line */
static bool parse_name_from_reply(const char *rx, char *out, size_t out_sz)
{
  if (!out || out_sz == 0) return false;
  out[0] = 0;

  // If reply contains "...NAME:Something", copy after ':'
  const char *p = strstr(rx, "NAME");
  if (p) {
    const char *colon = strchr(p, ':');
    p = colon ? (colon + 1) : rx;
  } else {
    p = rx;
  }

  strncpy(out, p, out_sz - 1);
  out[out_sz - 1] = 0;
  trim_ascii(out);

  // filter obvious non-name lines
  if (out[0] == 0) return false;
  if (!strcasecmp(out, "OK")) return false;
  if (!strncasecmp(out, "OK+", 3)) return false;
  if (!strncasecmp(out, "POWER", 5)) return false;

  return true;
}

/* ---------------- Watch variables (see in debugger) --------------- */
static volatile uint32_t g_beat = 0;     // proves the loop is alive
static uint8_t  g_last_rx[128];          // last reply raw bytes
static uint32_t g_last_len = 0;          // length of last reply
static char     g_name[32];              // parsed module name (best effort)
static uint8_t  g_name_len = 0;
static uint8_t  g_connected = 0;         // crude connection flag from text

/* ---------------- Main ---------------- */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART2_UART_Init();

  HAL_Delay(100);        // small power-on settle
  drain_uart(80);        // flush any banner

  /* Probe basic AT */
  g_last_len = send_and_read("AT\r\n", g_last_rx, sizeof(g_last_rx), 300);

  /* Try common name queries */
  const char *qnames[] = { "AT+NAME?\r\n", "AT+BTNAME?\r\n", "AT+GNAME\r\n" };
  g_name[0] = 0;
  for (unsigned i = 0; i < sizeof(qnames)/sizeof(qnames[0]); ++i) {
    g_last_len = send_and_read(qnames[i], g_last_rx, sizeof(g_last_rx), 400);

    /* parse last non-empty line of the reply */
    char tmp[sizeof(g_last_rx) + 1];
    memset(tmp, 0, sizeof(tmp));
    memcpy(tmp, g_last_rx, (g_last_len < sizeof(g_last_rx)) ? g_last_len : sizeof(g_last_rx));

    char *line = tmp, *last_non_empty = NULL;
    while (line && *line) {
      char *next = strpbrk(line, "\r\n");
      if (next) { *next = 0; next += 1; if (*next == '\n') next += 1; }
      char probe[64]; strncpy(probe, line, sizeof(probe)-1); probe[sizeof(probe)-1] = 0;
      trim_ascii(probe);
      if (probe[0] != 0) last_non_empty = line;
      line = next;
    }
    if (last_non_empty) {
      char parsed[64] = {0};
      if (parse_name_from_reply(last_non_empty, parsed, sizeof(parsed))) {
        strncpy(g_name, parsed, sizeof(g_name)-1);
        g_name_len = (uint8_t)strlen(g_name);
        break;
      }
    }
  }

  /* ---- Poll forever: update g_last_rx/g_connected; g_beat increments ---- */
  for (;;) {
    g_beat++;  // watch this in Expressions to see the loop running

    g_last_len = send_and_read("AT+STAT?\r\n", g_last_rx, sizeof(g_last_rx), 300);
    if (g_last_len == 0) {
      // fall back to a simple AT if STAT is unsupported
      g_last_len = send_and_read("AT\r\n", g_last_rx, sizeof(g_last_rx), 300);
    }

    // quick text check for link state
    char view[sizeof(g_last_rx) + 1];
    memset(view, 0, sizeof(view));
    memcpy(view, g_last_rx, (g_last_len < sizeof(g_last_rx)) ? g_last_len : sizeof(g_last_rx));

    if (strstr(view, "CONNECTED") || strstr(view, "A\r") || strstr(view, "A\n"))
      g_connected = 1;
    else if (strstr(view, "DISCONNECTED") || strstr(view, "a\r") || strstr(view, "a\n"))
      g_connected = 0;

    HAL_Delay(1000);
  }
}

void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;   // ~2.097 MHz
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
                              | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_MSI;
  RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) {
    Error_Handler();
  }
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) { /* stay here */ }
}
