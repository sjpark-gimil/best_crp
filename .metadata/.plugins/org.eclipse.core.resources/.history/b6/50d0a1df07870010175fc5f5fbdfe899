
#include "main.h"
#include "usart.h"
#include "gpio.h"
#include <string.h>
#include <stdbool.h>

extern UART_HandleTypeDef huart2;

/* Read bytes until there's a quiet period of `silence_ms` (no RX) or the buffer fills. */
static uint32_t read_until_silence(uint8_t *buf, uint32_t maxlen, uint32_t silence_ms)
{
    uint32_t i = 0;
    while (i < maxlen) {
        uint8_t b;
        if (HAL_UART_Receive(&huart2, &b, 1, silence_ms) == HAL_OK) {
            buf[i++] = b;
        } else {
            break; // no byte for silence_ms
        }
    }
    return i;
}

/* ==== prototypes generated by Cube ==== */
void SystemClock_Config(void);
void Error_Handler(void);

/* ---------------- Main ---------------- */
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART2_UART_Init();

    static uint8_t rxbuf[128];
    uint32_t n;

    /* 1) Flush any banner already sitting in the UART */
    (void)read_until_silence(rxbuf, sizeof(rxbuf), 50);

    const char *cmds[] = {
        "AT\r\n",          // sanity (should reply OK or similar)
        "AT+HELP\r\n",     // many Firmtech modules list commands
        "AT+NAME?\r\n",    // common query
        "AT+BTNAME?\r\n",  // alt spelling some modules use
        "AT+GNAME\r\n"     // some use GET-NAME without '?'
    };
    for (int i = 0; i < (int)(sizeof(cmds)/sizeof(cmds[0])); ++i) {
        HAL_UART_Transmit(&huart2, (uint8_t*)cmds[i], (uint16_t)strlen(cmds[i]), 200);
        n = read_until_silence(rxbuf, sizeof(rxbuf), 300);
        __BKPT(0);   // <-- constant. Inspect variable `i`, `n`, and `rxbuf` in the debugger.
    }
    /* Sit here forever */
    for (;;) HAL_Delay(1000);
}

/* ==== your existing clock + error handlers below (unchanged) ==== */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
    RCC_OscInitStruct.MSIState = RCC_MSI_ON;
    RCC_OscInitStruct.MSICalibrationValue = 0;
    RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) Error_Handler();

    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                                |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) Error_Handler();
}

void Error_Handler(void)
{
    __disable_irq();
    while (1) { }
}
