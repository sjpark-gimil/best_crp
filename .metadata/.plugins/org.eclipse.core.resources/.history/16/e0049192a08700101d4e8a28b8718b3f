
#include "main.h"
#include "usart.h"
#include "gpio.h"
#include <string.h>
#include <stdbool.h>

extern UART_HandleTypeDef huart2;

static void drain_uart(uint32_t ms) {
    uint8_t d;
    uint32_t t0 = HAL_GetTick();
    while ((HAL_GetTick() - t0) < ms) {
        if (HAL_UART_Receive(&huart2, &d, 1, 10) == HAL_OK)
            t0 = HAL_GetTick(); // extend while bytes keep arriving
    }
}

static uint32_t read_until_quiet(uint8_t *buf, uint32_t bufsz, uint32_t quiet_ms) {
    uint32_t n = 0, t0 = HAL_GetTick();
    for (;;) {
        uint8_t b;
        if (HAL_UART_Receive(&huart2, &b, 1, 10) == HAL_OK) {
            if (n < bufsz) buf[n++] = b;
            t0 = HAL_GetTick();
        }
        if ((HAL_GetTick() - t0) >= quiet_ms) break;
    }
    return n;
}

static uint8_t rxbuf[128];
(void)read_until_quiet(rxbuf, sizeof(rxbuf), 300);


/* ==== prototypes generated by Cube ==== */
void SystemClock_Config(void);
void Error_Handler(void);

/* ---------------- Main ---------------- */
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART2_UART_Init();

    static uint8_t rxbuf[128];
    uint32_t n;

    const char *cmds[] = {
        "AT\r\n",
        "AT\r",
        "AT+HELP\r\n",
        "AT+NAME?\r\n",
        "AT+BTNAME?\r\n",
        "AT+GNAME\r\n",
        "+++"
    };

    for (int i = 0; i < (int)(sizeof(cmds)/sizeof(cmds[0])); ++i) {
        if (i == 6) { // "+++"
            HAL_Delay(1000);
            n = send_and_read(cmds[i], rxbuf, sizeof(rxbuf), 800);
            HAL_Delay(1000);
        } else {
            n = send_and_read(cmds[i], rxbuf, sizeof(rxbuf), 400);
        }
        __BKPT(0);  // stop, check i, n, and rxbuf
    }

    for (;;) { HAL_Delay(1000); }
}

/* ==== your existing clock + error handlers below (unchanged) ==== */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
    RCC_OscInitStruct.MSIState = RCC_MSI_ON;
    RCC_OscInitStruct.MSICalibrationValue = 0;
    RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) Error_Handler();

    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                                |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) Error_Handler();
}

void Error_Handler(void)
{
    __disable_irq();
    while (1) { }
}
