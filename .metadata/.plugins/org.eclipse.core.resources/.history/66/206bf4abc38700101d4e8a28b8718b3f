/* ==== main.c (clean, no LEDs/breakpoints) ==== */
#include "main.h"
#include "gpio.h"
#include "usart.h"
#include <string.h>
#include <stdbool.h>
#include <stdint.h>

/* ---- Forward decls generated by Cube ---- */
void SystemClock_Config(void);

/* ---- Use USART2 (PA2/PA3) ---- */
extern UART_HandleTypeDef huart2;

/* ---- Small helpers ------------------------------------------------------- */

/* Drain any bytes arriving for a window; extends while data keeps coming. */
static void drain_uart(uint32_t ms)
{
  uint8_t d;
  uint32_t t0 = HAL_GetTick();
  for (;;)
  {
    if (HAL_UART_Receive(&huart2, &d, 1, 5) == HAL_OK)
    {
      t0 = HAL_GetTick();            // extend while bytes keep arriving
      continue;
    }
    if ((HAL_GetTick() - t0) >= ms)  // quiet for 'ms' -> done
      break;
  }
}

/* Send a command string and collect reply until quiet_ms of silence. */
static uint32_t send_and_read(const char *cmd,
                              uint8_t *buf, uint32_t bufsz,
                              uint32_t quiet_ms)
{
  // clear output buffer
  for (uint32_t i = 0; i < bufsz; ++i) buf[i] = 0;

  // ensure no stale bytes
  drain_uart(50);

  // TX command
  (void)HAL_UART_Transmit(&huart2, (uint8_t*)cmd, (uint16_t)strlen(cmd), 200);

  // RX until quiet
  uint32_t n = 0;
  uint32_t t0 = HAL_GetTick();
  for (;;)
  {
    uint8_t b;
    if (HAL_UART_Receive(&huart2, &b, 1, 5) == HAL_OK)
    {
      if (n < bufsz) buf[n++] = b;
      t0 = HAL_GetTick();
      continue;
    }
    if ((HAL_GetTick() - t0) >= quiet_ms) break;
  }
  return n;
}

/* Trim CR/LF and spaces at both ends (in-place) */
static void trim_ascii(char *s)
{
  // left trim
  size_t start = 0;
  while (s[start] == '\r' || s[start] == '\n' || s[start] == ' ' || s[start] == '\t')
    start++;
  if (start) memmove(s, s + start, strlen(s + start) + 1);

  // right trim
  size_t len = strlen(s);
  while (len && (s[len-1] == '\r' || s[len-1] == '\n' || s[len-1] == ' ' || s[len-1] == '\t'))
    s[--len] = 0;
}

/* Try to extract a name from a typical reply line */
static bool parse_name_from_reply(const char *rx, char *out, size_t out_sz)
{
  if (!out || out_sz == 0) return false;
  out[0] = 0;

  // Common patterns seen on BLE modules:
  // "OK+NAME:MyDevice", "+NAME:MyDevice", "NAME: MyDevice", or just "MyDevice"
  const char *p = NULL;

  if ((p = strstr(rx, "NAME")) != NULL)
  {
    // find ':' after NAME
    p = strchr(p, ':');
    if (p) p++;          // move past ':'
    else p = rx;         // fallback to full string
  }
  else
  {
    p = rx;              // fallback: whole string
  }

  // Copy the line into out and trim
  strncpy(out, p, out_sz - 1);
  out[out_sz - 1] = 0;
  trim_ascii(out);

  // If after trimming it still contains spaces/ok banners, try last token
  if (strlen(out) == 0) return false;

  // Heuristic: if "OK" lines exist, pick the last non-empty line
  // (Already handled by caller choosing the line to pass)

  return true;
}

/* ---- Debug/watch variables (see in Variables view) ----------------------- */
static uint8_t  g_last_rx[128];      // last reply buffer
static uint32_t g_last_len = 0;      // last reply length
static char     g_name[32];          // parsed device name
static uint8_t  g_name_len = 0;
static uint8_t  g_connected = 0;     // 0 = not sure/false, 1 = connected (best effort)

/* ---------------- Main ---------------- */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART2_UART_Init();

  // Give the module a moment after power-on
  HAL_Delay(100);

  // 1) Flush any boot banner
  drain_uart(80);

  // 2) Probe basic AT
  g_last_len = send_and_read("AT\r\n", g_last_rx, sizeof(g_last_rx), 300);

  // 3) Try to query name with several common forms
  const char *qnames[] = {
    "AT+NAME?\r\n",
    "AT+BTNAME?\r\n",
    "AT+GNAME\r\n"
  };

  g_name[0] = 0;
  for (unsigned i = 0; i < sizeof(qnames)/sizeof(qnames[0]); ++i)
  {
    g_last_len = send_and_read(qnames[i], g_last_rx, sizeof(g_last_rx), 400);

    // Convert buffer to a C-string for parsing (safe: room for extra 0)
    char tmp[sizeof(g_last_rx) + 1];
    memset(tmp, 0, sizeof(tmp));
    memcpy(tmp, g_last_rx, (g_last_len < sizeof(g_last_rx)) ? g_last_len : sizeof(g_last_rx));

    // Try to parse the last non-empty line as name
    char *line = tmp;
    char *last_non_empty = NULL;
    while (line && *line)
    {
      char *next = strpbrk(line, "\r\n");
      if (next) { *next = 0; next += 1; if (*next == '\n') next += 1; }
      char probe[64];
      strncpy(probe, line, sizeof(probe) - 1);
      probe[sizeof(probe) - 1] = 0;
      trim_ascii(probe);
      if (probe[0] != 0) last_non_empty = line;
      line = next;
    }

    if (last_non_empty)
    {
      char parsed[64];
      memset(parsed, 0, sizeof(parsed));
      if (parse_name_from_reply(last_non_empty, parsed, sizeof(parsed)))
      {
        // Guard against "OK" etc.
        if (strcasecmp(parsed, "OK") != 0 &&
            strncasecmp(parsed, "OK+", 3) != 0 &&
            strncasecmp(parsed, "POWER", 5) != 0)
        {
          strncpy(g_name, parsed, sizeof(g_name) - 1);
          g_name_len = (uint8_t)strlen(g_name);
          break;
        }
      }
    }
  }

  // 4) Main poll loop â€” keep an eye on "connected" & keep last reply for you
  for (;;)
  {
    // Best-effort: try a status command if supported, else simple "AT"
    g_last_len = send_and_read("AT+STAT?\r\n", g_last_rx, sizeof(g_last_rx), 300);
    if (g_last_len == 0)
      g_last_len = send_and_read("AT\r\n", g_last_rx, sizeof(g_last_rx), 300);

    // Heuristic to set g_connected based on reply content seen on similar modules
    // Adjust later if manual gives exact tokens.
    // Examples this will catch: "A" vs "a", "CONNECTED", "DISCONNECTED"
    char view[sizeof(g_last_rx) + 1];
    memset(view, 0, sizeof(view));
    memcpy(view, g_last_rx, (g_last_len < sizeof(g_last_rx)) ? g_last_len : sizeof(g_last_rx));
    // Normalize simple signals
    if (strstr(view, "CONNECTED") || strstr(view, "A\r") || strstr(view, "A\n"))
      g_connected = 1;
    else if (strstr(view, "DISCONNECTED") || strstr(view, "a\r") || strstr(view, "a\n"))
      g_connected = 0;
    // else leave as is (unknown)

    HAL_Delay(1000);
  }
}

/* ==== end of file ==== */
