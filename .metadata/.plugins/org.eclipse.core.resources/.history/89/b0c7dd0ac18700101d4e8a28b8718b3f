/* USER CODE BEGIN Header */
/*
 * Minimal probe for Firmtech FBL601 (or similar AT UART BLE module)
 * Board: STM32L100C6 (HAL)
 * Peripherals expected from .ioc:
 *   - USART2 @ 9600 8-N-1
 *   - GPIO clocks enabled (A,B)
 *
 * What it does:
 *   1) Drains any banner already in the UART.
 *   2) Sends a small set of AT queries one by one.
 *   3) Captures the reply bytes into rxbuf.
 *   4) Halts at BKPT after each query so you can inspect rxbuf[0..n-1].
 *   5) (optional) Prints replies over SWV (ITM Port 0).
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "gpio.h"
#include "usart.h"
#include <string.h>
#include <stdbool.h>
#include <stdio.h>

/* ================== Optional SWV logging ================== */
#define USE_SWV_LOG  1
#if USE_SWV_LOG
  #include "core_cm3.h"
  static inline void ITM_SendString(const char *s) {
    if (!s) return;
    while (*s) {
      /* Wait until ITM and stimulus port 0 are ready */
      while ((ITM->TCR & ITM_TCR_ITMENA_Msk) == 0U || (ITM->TER & 1U) == 0U) { __NOP(); }
      ITM->PORT[0].u8 = (uint8_t)*s++;
    }
  }
  #define SWV_LOG(msg) ITM_SendString(msg)
#else
  #define SWV_LOG(msg) do{}while(0)
#endif
/* ========================================================== */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void Error_Handler(void);

/* From usart.c generated by CubeMX */
extern UART_HandleTypeDef huart2;

/* ---------- small helpers ---------- */

/* Drain UART RX until link is quiet for 'ms' (extends while bytes arrive). */
static void drain_uart(uint32_t ms)
{
  uint8_t d;
  uint32_t t0 = HAL_GetTick();
  for (;;) {
    if (HAL_UART_Receive(&huart2, &d, 1, 5) == HAL_OK) {
      t0 = HAL_GetTick();  /* extend quiet timer while data keeps coming */
      continue;
    }
    if ((HAL_GetTick() - t0) >= ms) break;
  }
}

/* Send one command and read reply until quiet_ms of silence.
   Returns number of bytes stored in buf (up to bufsz). */
static uint32_t send_and_read(const char *cmd, uint8_t *buf, uint32_t bufsz, uint32_t quiet_ms)
{
  /* clear buffer */
  for (uint32_t i = 0; i < bufsz; ++i) buf[i] = 0;

  /* make sure no old bytes remain */
  drain_uart(60);

  /* send */
  (void)HAL_UART_Transmit(&huart2, (uint8_t*)cmd, (uint16_t)strlen(cmd), 200);

  /* collect reply */
  uint32_t n = 0;
  uint32_t t0 = HAL_GetTick();
  for (;;) {
    uint8_t b;
    if (HAL_UART_Receive(&huart2, &b, 1, 8) == HAL_OK) {
      if (n < bufsz) buf[n++] = b;
      t0 = HAL_GetTick();              /* restart quiet timer */
      continue;
    }
    if ((HAL_GetTick() - t0) >= quiet_ms) break;
  }
  return n;
}

/* ---------------- Main ---------------- */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART2_UART_Init();

  /* work buffers */
  static uint8_t rxbuf[256];
  uint32_t n;

  SWV_LOG("\r\n=== BLE probe start ===\r\n");

  /* 1) Flush any banner already present (you should see the banner in rxbuf if SWV off) */
  (void)send_and_read("", rxbuf, sizeof(rxbuf), 80);
  if (rxbuf[0]) {
    SWV_LOG("Banner:\r\n");
    SWV_LOG((const char*)rxbuf);
    SWV_LOG("\r\n-- end banner --\r\n");
  }

  /* 2) Try a sequence of likely commands */
  const char *cmds[] = {
      "AT\r\n",          /* sanity */
      "AT\r",            /* some modules ignore LF */
      "AT+HELP\r\n",     /* may list commands */
      "AT+NAME?\r\n",    /* common name query */
      "AT+BTNAME?\r\n",  /* alt spelling */
      "AT+GNAME\r\n",    /* some use GET-NAME without '?' */
      "AT+STATUS?\r\n"   /* status, if supported */
  };

  for (int i = 0; i < (int)(sizeof(cmds)/sizeof(cmds[0])); ++i) {
    char line[64];
    snprintf(line, sizeof(line), "\r\n>> %s", cmds[i]);
    SWV_LOG(line);

    n = send_and_read(cmds[i], rxbuf, sizeof(rxbuf), 400);

    /* Print to SWV if enabled */
    if (n > 0) {
      SWV_LOG("<< ");
      ITM_SendString((const char*)rxbuf);   /* rxbuf is not 0-terminated if full; good enough for viewing */
      SWV_LOG("\r\n");
    } else {
      SWV_LOG("<< (no reply)\r\n");
    }

    /* Always stop here so you can inspect:
       - variable 'i' (which command)
       - variable 'n' (reply length)
       - rxbuf[0..n-1] as ASCII in Variables view.
    */
    __BKPT(0);
  }

  SWV_LOG("\r\n=== BLE probe done; idling ===\r\n");
  for (;;) {
    HAL_Delay(1000);
  }
}

/* === Simple MSI clock setup (~2.1 MHz). If your .ioc already generates this,
 * you can keep that one instead. This version is intentionally minimal and safe. */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.MSIState       = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.MSIClockRange  = RCC_MSIRANGE_5;  /* ~2.097 MHz */
  RCC_OscInitStruct.PLL.PLLState   = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); }

  RCC_ClkInitStruct.ClockType      = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_MSI;
  RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { Error_Handler(); }

  /* SysTick already configured by HAL_Init() for 1ms tick using HCLK */
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) { __NOP(); }
}

